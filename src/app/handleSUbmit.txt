async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();

    if (!inputRef.current) return;
    const msg = inputRef.current.value.trim();
    if (!msg) return;

    setLoading(true);
    setFirst(true);

    // Clear input immediately
    inputRef.current.value = '';
    setValue('');

    try {
      // Get chatbot response
      const res = await fetch('/api/chatbot', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: msg }),
      });

      const data = await res.json();

      if (data.error) {
        // Handle error response
        const errorMessage: Message = {
          question: msg,
          answer: `Error: ${data.error}`,
          timeStamp: new Date()
        };

        setMessages(prev => [...prev, errorMessage]);
        return;
      }

      // Create complete message with bot response
      const completeMessage: Message = {
        question: msg,
        answer: typeof data === 'string' ? data : JSON.stringify(data),
        timeStamp: new Date()
      };

      // Update UI immediately
      setMessages(prev => [...prev, completeMessage]);

      // Save to database if user is signed in
      if (signedIn) {
        const store = await fetch('/api/app-info', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            question: msg,
            answer: completeMessage.answer
          }),
        });

        if (!store.ok) {
          console.error('Failed to save message:', await store.text());
        }
      }

    } catch (err) {
      console.error('Request failed:', err);
      const errorMessage: Message = {
        question: msg,
        answer: 'Failed to get response. Please try again.',
        timeStamp: new Date()
      };

      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setLoading(false);
    }